/*

1.项目优化
  代码层面:防抖节流、
  打包：
  渲染：
  加载：前端缓存，

2. 浏览器一些原理
3. mvvm原理
4.react原理
5.dom-diff 原理
6.redux原理
7.mobx原理
8.setState
9.vue生命周期
10.react生命周期
11.深拷贝




基础
1.盒模型
2.原型、继承、闭包、作用域
3.ES6 语法
4. let const
5.promise


设计模式：
装饰器模式
观察者模式

优化：
代码层面：按需引入 antd ，element-ui，如果用了moment，忽略他的语言包

防抖，节流，减少dom重绘


git push --set-upstream origin master

----------
所以正确的一次 Event loop 顺序是这样的

执行同步代码，这属于宏任务
执行栈为空，查询是否有微任务需要执行
执行所有微任务
必要的话渲染 UI
然后开始下一轮 Event loop，执行宏任务中的异步代码

-----------

status code: 200 ok ( from cache )
status code: 304 Not Modified
上面两种方式有什么区别呢？简单地说，第一种方式是不向浏览器发送请求，直接使用本地缓存文件。第二种方式，浏览器虽然发现了本地有该资源的缓存，但是不确定是否是最新的，于是想服务器询问，若服务器认为浏览器的缓存版本还可用，那么便会返回304。
浏览器如何决定是使用哪种方式呢？这就和服务器在请求返回中的Header字段有关了。下面对相关的字段进行简单介绍。

























 */



















